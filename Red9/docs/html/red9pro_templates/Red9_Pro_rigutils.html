<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pro_Pack : rigutils &mdash; Red9 3.0 documentation</title><link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Pro_Pack : shaders" href="Red9_Pro_shaders.html" />
    <link rel="prev" title="Pro_Pack : r9file" href="Red9_Pro_r9file.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> Red9<img src="../_static/Red9_ProPack_logo.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                3.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../red9core_templates/Red9_AnimationUtils.html">Red9_AnimationUtils</a></li>
<li class="toctree-l1"><a class="reference internal" href="../red9core_templates/Red9_Audio.html">Red9_Audio</a></li>
<li class="toctree-l1"><a class="reference internal" href="../red9core_templates/Red9_Core.html">Red9_CoreUtils</a></li>
<li class="toctree-l1"><a class="reference internal" href="../red9core_templates/Red9_General.html">Red9_General</a></li>
<li class="toctree-l1"><a class="reference internal" href="../red9core_templates/Red9_Meta.html">Red9_Meta</a></li>
<li class="toctree-l1"><a class="reference internal" href="../red9core_templates/Red9_PoseSaver.html">Red9_PoseSaver</a></li>
<li class="toctree-l1"><a class="reference internal" href="../red9core_templates/Red9_Setup.html">Red9_Setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="../red9core_templates/Red9_Tools.html">Red9_Tools</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Red9_Pro_anim_map.html">Pro_Pack : anim_map</a></li>
<li class="toctree-l1"><a class="reference internal" href="Red9_Pro_animation.html">Pro_Pack : animation</a></li>
<li class="toctree-l1"><a class="reference internal" href="Red9_Pro_audio.html">Pro_Pack : audio</a></li>
<li class="toctree-l1"><a class="reference internal" href="Red9_Pro_capture.html">Pro_Pack : capture</a></li>
<li class="toctree-l1"><a class="reference internal" href="Red9_Pro_deformers.html">Pro_Pack : deformers</a></li>
<li class="toctree-l1"><a class="reference internal" href="Red9_Pro_export.html">Pro_Pack : exporter</a></li>
<li class="toctree-l1"><a class="reference internal" href="Red9_Pro_general.html">Pro_Pack : general</a></li>
<li class="toctree-l1"><a class="reference internal" href="Red9_Pro_importexport.html">Pro_Pack : importexport</a></li>
<li class="toctree-l1"><a class="reference internal" href="Red9_Pro_metadata_pro.html">Pro_Pack : metadata_pro</a></li>
<li class="toctree-l1"><a class="reference internal" href="Red9_Pro_optimiser.html">Pro_Pack : optimiser</a></li>
<li class="toctree-l1"><a class="reference internal" href="Red9_Pro_perforce.html">Pro_Pack : perforce</a></li>
<li class="toctree-l1"><a class="reference internal" href="Red9_Pro_project.html">Pro_Pack : project</a></li>
<li class="toctree-l1"><a class="reference internal" href="Red9_Pro_r9data.html">Pro_Pack : r9Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="Red9_Pro_r9file.html">Pro_Pack : r9file</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Pro_Pack : rigutils</a></li>
<li class="toctree-l1"><a class="reference internal" href="Red9_Pro_shaders.html">Pro_Pack : shaders</a></li>
<li class="toctree-l1"><a class="reference internal" href="Red9_Pro_skinning.html">Pro_Pack : skinning</a></li>
<li class="toctree-l1"><a class="reference internal" href="Red9_Pro_uibase.html">Pro_Pack : uibase</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="tools/Red9_Pro_anim_binder.html">Pro_Pack : tools : anim_binder</a></li>
<li class="toctree-l1"><a class="reference internal" href="tools/Red9_Pro_anim_tools.html">Pro_Pack : tools : anim_tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="tools/Red9_Pro_anim_trails.html">Pro_Pack : tools : anim_trails</a></li>
<li class="toctree-l1"><a class="reference internal" href="tools/Red9_Pro_deformer_tools.html">Pro_Pack : tools : deformer_tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="tools/Red9_Pro_health_manager.html">Pro_Pack : tools : health_manager</a></li>
<li class="toctree-l1"><a class="reference internal" href="tools/Red9_Pro_metahuman_tools.html">Pro_Pack : tools : metahuman_tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="tools/Red9_Pro_project_manager.html">Pro_Pack : tools : project_manager</a></li>
<li class="toctree-l1"><a class="reference internal" href="tools/Red9_Pro_rig_manager.html">Pro_Pack : tools : rig_manager</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="puppet/Red9_Pro_finger_pose_creator.html">Pro_Pack : puppet : finger_pose_creator</a></li>
<li class="toctree-l1"><a class="reference internal" href="puppet/Red9_Pro_ikfk_match.html">Pro_Pack : puppet : ikfk_match</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Red9</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Pro_Pack : rigutils</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/red9pro_templates/Red9_Pro_rigutils.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="pro-pack-rigutils">
<h1>Pro_Pack : rigutils<a class="headerlink" href="#pro-pack-rigutils" title="Permalink to this headline">¶</a></h1>
<p>ProPack rigutils module contains useful tools for managing both rig
and skeletal data for the ProPack systems.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># import statement for the module via the r9pro decompiler</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Red9.pro_pack</span> <span class="k">import</span> <span class="n">r9pro</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r9rigutils</span> <span class="o">=</span> <span class="n">r9pro</span><span class="o">.</span><span class="n">r9import</span><span class="p">(</span><span class="s1">&#39;r9rigutils&#39;</span><span class="p">)</span>
</pre></div>
</div>
<span class="target" id="module-Red9.pro_pack.core.rigutils"></span><p>This module contains core rigging utils used through out the systems</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="function">
<dt id="Red9.pro_pack.core.rigutils.swapshapes">
<code class="descname">swapshapes</code><span class="sig-paren">(</span><em>source</em>, <em>target</em>, <em>replace=True</em>, <em>worldspace=True</em>, <em>delete_source=True</em>, <em>rename_shapes=True</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.rigutils.swapshapes" title="Permalink to this definition">¶</a></dt>
<dd><p>from a source transform parent all shapes under the target transform.
If replace is True we delete all current shapes under the target.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>source</strong> – the source transform who’s shapes we’re going to move</li>
<li><strong>target</strong> – destination transform we’ll be parenting the shapes under</li>
<li><strong>replace</strong> – True by default, do we remove all current shapes from the target before we re-parent the new ones?</li>
<li><strong>worldspace</strong> – if True we maintain the shapes current world positions else we use default Maya relative shape parenting</li>
<li><strong>delete_source</strong> – delete the source after the process is complete</li>
<li><strong>rename_shapes</strong> – if True we numerically rename all shapes in the form ‘nodename_Shape%i’ where %i is incremented
per shape, the numeric however is only added if there’s more than 1 child shape</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Red9.pro_pack.core.rigutils.set_shape_colors">
<code class="descname">set_shape_colors</code><span class="sig-paren">(</span><em>nodes=[]</em>, <em>index=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.rigutils.set_shape_colors" title="Permalink to this definition">¶</a></dt>
<dd><p>set the shape colour overrides of all child shapes to a given index</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nodes</strong> – nodes to process, if not given we use selected</li>
<li><strong>index</strong> – the Maya colour index to assign</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Red9.pro_pack.core.rigutils.opm_offset_parent_matrix_constraint">
<code class="descname">opm_offset_parent_matrix_constraint</code><span class="sig-paren">(</span><em>source=None</em>, <em>target=None</em>, <em>mo=True</em>, <em>zero_xforms=False</em>, <em>translates=True</em>, <em>rotates=True</em>, <em>scales=True</em>, <em>shear=True</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.rigutils.opm_offset_parent_matrix_constraint" title="Permalink to this definition">¶</a></dt>
<dd><p>offsetParentMatrix handlers: replacement of the parentConstraint but using the offsetParentMatrix
wires with optional maintain offset (unlike manually wiring this connection)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>source</strong> – the driver source node</li>
<li><strong>target</strong> – the target node to accept the input from the source</li>
<li><strong>mo</strong> – like constraints this maintains the nodes current transforms after the worldMatrix has been plugged</li>
<li><strong>zero_xforms</strong> – zero off all the target nodes transforms after we hook the plug up,
leaving you with the node in place with zerp transforms</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">this process hard aborts if the target is a joint as the jointOrients break the opm matrix data with rotates</p>
</div>
</dd></dl>

<dl class="function">
<dt id="Red9.pro_pack.core.rigutils.opm_freeze_transforms_to_composition_chns">
<code class="descname">opm_freeze_transforms_to_composition_chns</code><span class="sig-paren">(</span><em>nodes=[]</em>, <em>compensate=True</em>, <em>force=True</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.rigutils.opm_freeze_transforms_to_composition_chns" title="Permalink to this definition">¶</a></dt>
<dd><p>offsetParentMatrix handlers: simple proc that copies the current transform data over to the composition channels
and resets the xforms. This results in zero xforms but the node in the same space. We compensate for any existing
matrix data in the composition channels during the process.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nodes</strong> – the nodes to process, if not given we use the currently selected objects</li>
<li><strong>compensate</strong> – if True (default), we compensate for any current matrix data in the composition before
we push the current transform matrix over to those channels.</li>
<li><strong>force</strong> – if True (default) and the current transforms are locked then we force unlock and re-lock after we’ve reset them</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">joints cause issues with this process because of the extra matrix from the joint orients which we don’t currently deal with
so we only process the transform data and reset the rotation data regardless</p>
</div>
</dd></dl>

<dl class="function">
<dt id="Red9.pro_pack.core.rigutils.opm_delete_and_reset">
<code class="descname">opm_delete_and_reset</code><span class="sig-paren">(</span><em>nodes=[]</em>, <em>compensate=True</em>, <em>inherit_managed=False</em>, <em>inherits_transform=True</em>, <em>reset_rotate_axis=True</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.rigutils.opm_delete_and_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>examine the given nodes and if thei’re connected via opm, remove that link and reset the opm matrix
:param compensate: if True (default), we compensate for any change in the nodes xforms that would result from simply resetting the composition matrix data
:param inherit_managed: if True we manage the state of the inheritTransform flag on the nodes and set it’s value to the inherits_transform flag
:param inherits_transform: usd in conjunction with the inherit_managed flag, set the state of the inheritTransform on the nodes during the reset process.</p>
<blockquote>
<div>With OPM we often turn off the inheritTransforms of nodes for them to act correctly</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="Red9.pro_pack.core.rigutils.opm_reset_composition_to_transform_chns">
<code class="descname">opm_reset_composition_to_transform_chns</code><span class="sig-paren">(</span><em>nodes=[]</em>, <em>compensate=True</em>, <em>inherit_managed=False</em>, <em>inherits_transform=True</em>, <em>reset_rotate_axis=True</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.rigutils.opm_reset_composition_to_transform_chns" title="Permalink to this definition">¶</a></dt>
<dd><p>offsetParentMatrix handlers: simple proc that resets the matrix in the composition channels
and pushes that to the nodes xforms, re-compensating for any other transforms in those channels at the same time</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nodes</strong> – the nodes to process, if not given we use the currently selected objects</li>
<li><strong>compensate</strong> – if True (default), we compensate for any change in the nodes xforms that would result from simply resetting the composition matrix data</li>
<li><strong>inherit_managed</strong> – if True we manage the state of the inheritTransform flag on the nodes and set it’s value to the inherits_transform flag</li>
<li><strong>inherits_transform</strong> – usd in conjunction with the inherit_managed flag, set the state of the inheritTransform on the nodes during the reset process.
With OPM we often turn off the inheritTransforms of nodes for them to act correctly</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">joints cause issues with this process because of the extra matrix from the joint orients which we don’t currently deal with</p>
</div>
</dd></dl>

<dl class="function">
<dt id="Red9.pro_pack.core.rigutils.opm_get_matrix">
<code class="descname">opm_get_matrix</code><span class="sig-paren">(</span><em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.rigutils.opm_get_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>simple extraction of the opm matrix</p>
</dd></dl>

<dl class="function">
<dt id="Red9.pro_pack.core.rigutils.get_lod_groups">
<code class="descname">get_lod_groups</code><span class="sig-paren">(</span><em>lodroot</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.rigutils.get_lod_groups" title="Permalink to this definition">¶</a></dt>
<dd><p>from a root lodGroup node return the child LOD connections as a dict.
If the given isn’t of type lodGroup then we inspect the child grps for name
based extraction, searching for “LOD” (case doesn’t matter), then use the trailing int
somename_LOD_1, somename_LOD1, somename_lod_1_grp all will return as lod 1</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>lodroot</strong> – the upper parent root of the lods</td>
</tr>
</tbody>
</table>
<p>return: {0:LOD_0_grp, 1:LOD_01_grp … }</p>
</dd></dl>

<dl class="function">
<dt id="Red9.pro_pack.core.rigutils.get_missing_parents_from_hierarchy">
<code class="descname">get_missing_parents_from_hierarchy</code><span class="sig-paren">(</span><em>nodes</em>, <em>select=False</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.rigutils.get_missing_parents_from_hierarchy" title="Permalink to this definition">¶</a></dt>
<dd><p>from a given list of nodes, full dag_paths, find any nodes within the hierarchy
that aren’t actually in the node list and return. These would usually be parents
and groups at the top of a hierarchy.</p>
<p>for example: 
&gt;&gt;&gt; nodes = [‘MASTER_NODE|skeleton|root’,’MASTER_NODE|skeleton|root|pelvis’]
&gt;&gt;&gt; get_missing_nodes_from_hierarchy(dag_paths)
&gt;&gt;&gt; # return # [‘<a href="#id1"><span class="problematic" id="id2">|</span></a>MASTER_NODE’, ‘<a href="#id3"><span class="problematic" id="id4">|</span></a>MASTER_NODE|skeleton’]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nodes</strong> – list of full dag paths to inspect</li>
<li><strong>select</strong> – if True we select the nodes returned</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Red9.pro_pack.core.rigutils.skeleton_root">
<code class="descname">skeleton_root</code><span class="sig-paren">(</span><em>joint=None</em>, <em>from_child=True</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.rigutils.skeleton_root" title="Permalink to this definition">¶</a></dt>
<dd><p>return the name of the root joint in the hierarchy from the given child jnt
by walking up the hierarchy to the top most joint</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>joint</strong> – name of a joint in the hierarchy</li>
<li><strong>from_child</strong> – True by default, are we walking up the hierarchy to find a root_joint, or are
we walking down it to find the first child root_joint?</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">name of the root joint in the hierarchy</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Red9.pro_pack.core.rigutils.skeleton_pose_get_data">
<code class="descname">skeleton_pose_get_data</code><span class="sig-paren">(</span><em>rootjnt, attr='bpose', jntonly=False, suppress=False, nodetypes=['joint']</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.rigutils.skeleton_pose_get_data" title="Permalink to this definition">¶</a></dt>
<dd><p>simple retrieval of the “BPose” or “TPose” PoseDict object which is
stored on the skeleton root by the RigManager. These Poses are used
by the additive fbx export to force reset the skeleton pose before processing.
We find the jnt stamped with the given attr by filtering the hierarchy for that
attr rather than assuming that it’s always on the rootjnt</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>rootjnt</strong> – the root joint of the skeleton we want to get the Pose data from</li>
<li><strong>attr</strong> – ‘bpose’ or ‘tpose’ depending on what data you want to get</li>
<li><strong>jntonly</strong> – if True we return only the joint that the bpose is stamped onto, else we return the poseDict itself</li>
<li><strong>suppress</strong> – by default we warn if the same pose attr is found on multiple joints in the skeleton hierarchy,
this flag suppresses that warning and force uses the first matching attr found. If suppress=True and jntonly=True
the return is a list of jnts (there may be multiple if there have been duplicated jnts in the past)</li>
<li><strong>nodetypes</strong> – [] types of nodes we’re going to scan to find any existing pose attr data, default [‘joint’]</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This will now raise an error if the skeleton has multiple joints with the “bpose” / “tpose” attr
stamped, this can happen if you simply duplicate the root joitn and useif for an additional joint
in the skeleton, hence the check! also see specific HealthTest: “r9popt.exportTag_bpose_test”</p>
</div>
</dd></dl>

<dl class="function">
<dt id="Red9.pro_pack.core.rigutils.skeleton_pose_current">
<code class="descname">skeleton_pose_current</code><span class="sig-paren">(</span><em>rootjnt, nodetypes=['joint']</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.rigutils.skeleton_pose_current" title="Permalink to this definition">¶</a></dt>
<dd><p>simple proc to return an r9Pose.poseDict based on the current skeletons pose</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>rootjnt</strong> – the root joint of the skeleton we want to get the Pose data from</li>
<li><strong>nodetypes</strong> – [] types of nodes we’re going to scan to find any existing pose attr data, default [‘joint’]</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Red9.pro_pack.core.rigutils.skeleton_pose_load">
<code class="descname">skeleton_pose_load</code><span class="sig-paren">(</span><em>rootjnt, attr=None, filepath=None, skip_translates=False, skip_scales=True, specific_jnts=[], skip_attrs=['radius', 'visibility', 'scaleX', 'scaleY', 'scaleZ', 'jointOrientX', 'jointOrientY', 'jointOrientZ', 'segmentScaleCompensate'], custom_root=None, suppress=True, nodetypes=['joint'], matchMethod='base'</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.rigutils.skeleton_pose_load" title="Permalink to this definition">¶</a></dt>
<dd><p>restore the characters skeleton to the original pose stored on the attr given, or from the filepath.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">We ensure during the load that the skeleton only has 1 matching attr stamped in the joint
hierarchy for that pose. If you’ve duplicated the root joint and used that for another joint
then there is a chance that duplicated joint may carry a previous bpose / tpose!</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>rootjnt</strong> – the root joint of the skeleton we want to get the Pose data from</li>
<li><strong>attr</strong> – the attr we’re going to pull the pose from (if given)</li>
<li><strong>filepath</strong> – filepath to a stored pose</li>
<li><strong>skip_translates</strong> – only load the rotate data if True. Aimed at loading T &amp; B Poses</li>
<li><strong>skip_scales</strong> – True by default, do not load any scale data back</li>
<li><strong>skip_attrs</strong> – attrs to ignore during the load process default : [‘radius’, ‘visibility’, ‘jointOrientX’, ‘jointOrientY’, ‘jointOrientZ’]</li>
<li><strong>custom_root</strong> – if given this skeleton will be used to load the pose onto. Note that this is only valid
if attr is set, the rootjnt skeleton is used to pull the pose data, but the load happens on the additional custom_root skeleton</li>
<li><strong>specific_jnts</strong> – if given then we only load data to the given list of joints, else we process the full hierarchy from the rootjnt.
Note: the rootjnt is still required for this process as in attr mode we search and extract the b/tpose data directly from it</li>
<li><strong>suppress</strong> – by default we warn if the same pose attr is found on multiple joints in the skeleton hierarchy,
this flag suppresses that warning and force uses the first matching attr found</li>
<li><strong>nodetypes</strong> – [] types of nodes we’re going to scan to find any existing pose attr data, default [‘joint’]</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Red9.pro_pack.core.rigutils.skeleton_pose_save">
<code class="descname">skeleton_pose_save</code><span class="sig-paren">(</span><em>rootjnt, attr=None, filepath=None, suppress=False, posedict=None, nodetypes=['joint']</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.rigutils.skeleton_pose_save" title="Permalink to this definition">¶</a></dt>
<dd><p>save the characters current skeleton pose to either the given attr or to the filepath.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">We ensure during the load that the skeleton only has 1 matching attr stamped in the joint
hierarchy for that pose. If you’ve duplicated the root joint and used that for another joint
then there is a chance that duplicated joint may carry a previous bpose / tpose!</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>rootjnt</strong> – the root joint of the skeleton we want to get the Pose data from</li>
<li><strong>attr</strong> – the attr we’re going to pull the pose from (if given) we generally use ‘bpose’ or ‘tpose’</li>
<li><strong>filepath</strong> – filepath to a stored pose</li>
<li><strong>skip_translates</strong> – only load the rotate data if True. Aimed at loading T &amp; B Poses</li>
<li><strong>suppress</strong> – by default we warn if the same pose attr is found on multiple joints in the skeleton hierarchy,
this flag suppresses that warning and force uses the first matching attr found</li>
<li><strong>posedict</strong> – if given and saving to attr then this allows you to directly pass another posedict
to be stamped into the attr rather than sampling the skeletons current transforms. This is aimed
at pushing previous data and syncing assets already rigged</li>
<li><strong>nodetypes</strong> – [] types of nodes we’re going to scan to find any existing pose attr data, default [‘joint’]</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">if neither ‘attr’ or ‘filepath’ are given the code will prompt you for a filepath to save too</p>
</div>
</dd></dl>

<dl class="function">
<dt id="Red9.pro_pack.core.rigutils.skeleton_pose_delete">
<code class="descname">skeleton_pose_delete</code><span class="sig-paren">(</span><em>rootjnt, attr, nodetypes=['joint']</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.rigutils.skeleton_pose_delete" title="Permalink to this definition">¶</a></dt>
<dd><p>delete given pose from skeleton</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>rootjnt</strong> – the root joint of the skeleton we want to get the Pose data from</li>
<li><strong>attr</strong> – the attr we’re going to delete</li>
<li><strong>nodetypes</strong> – [] types of nodes we’re going to scan to find any existing pose attr data, default [‘joint’]</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">True if deleted</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Red9.pro_pack.core.rigutils.skeleton_pose_replace">
<code class="descname">skeleton_pose_replace</code><span class="sig-paren">(</span><em>rootjnt, filepath=None, attr='bpose', suppress=False, nodetypes=['joint']</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.rigutils.skeleton_pose_replace" title="Permalink to this definition">¶</a></dt>
<dd><p>simple replacement of the internal pose on the given attr with the data from the given pose file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>rootjnt</strong> – the root joint of the skeleton we want to get the Pose data from</li>
<li><strong>attr</strong> – the attr we’re going to push the pose file data too, default=’bpose’</li>
<li><strong>filepath</strong> – filepath for the pose we’re going to manage, if left blank we prompt for a filepath</li>
<li><strong>suppress</strong> – by default we warn if the same pose attr is found on multiple joints in the skeleton hierarchy,
this flag suppresses that warning and force uses the first matching attr found</li>
<li><strong>nodetypes</strong> – [] types of nodes we’re going to scan to find any existing pose attr data, default [‘joint’]</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Red9.pro_pack.core.rigutils.skeleton_pose_compare">
<code class="descname">skeleton_pose_compare</code><span class="sig-paren">(</span><em>rootjnt, filepath=None, attr=None, skip_attrs=['radius', 'visibility'], nodetypes=['joint'], suppress=True, longname=True, **kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.rigutils.skeleton_pose_compare" title="Permalink to this definition">¶</a></dt>
<dd><p>compare the current skeletal pose with the values from either a pose file OR one of the
internal poses stored on the skeleton (BPose or TPose)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>rootjnt</strong> – the root joint of the skeleton we want to get the Pose data from</li>
<li><strong>filepath</strong> – filepath to a stored pose which we want to compare the current skeleton pose against</li>
<li><strong>attr</strong> – the attr on the skeleton that we’re pulling the pose from to compare against, ‘bpose’ or ‘tpose’ by default</li>
<li><strong>skip_attrs</strong> – attrs we’re not interested in comparing, default [‘radius’, ‘visibility’]</li>
<li><strong>nodetypes</strong> – [] types of nodes we’re going to compare, default [‘joint’]</li>
<li><strong>longname</strong> – if True (default, we validate the dag path complete, else we use short name matching only</li>
<li><strong>suppress</strong> – suppress the results popup and just handle the return</li>
<li><strong>**kws</strong> – <p>passed directly to the r9Pose.PoseCompare object initialization</p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>#TODO: check why we#re NOT comparing against the skeletonDict. We currently have the compareDict set to</dt>
<dd>None which will compare the bpose to the poseDict in the referencePose solt!</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="Red9.pro_pack.core.rigutils.skeleton_pose_compare_attrs">
<code class="descname">skeleton_pose_compare_attrs</code><span class="sig-paren">(</span><em>skelA, skelB, attr='bpose', skip_attrs=['radius', 'visibility'], nodetypes=['joint'], longname=True, suppress=True</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.rigutils.skeleton_pose_compare_attrs" title="Permalink to this definition">¶</a></dt>
<dd><p>unlike the “skeleton_pose_compare” func this one compares the internal BPose / TPose
attrs of the 2 given skeletons which the skeleton_pose_save(rootjnt, attr)
stamps onto the root joint itself. Why? this is used during the Publish time
for the Red9 Puppet so that the binding process can verify that the 2 skeletons
are the same and bind appropriately</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>skelA</strong> – the prime skeleton that we’re comparing against</li>
<li><strong>skelB</strong> – the skeleton we’re comparing</li>
<li><strong>attr</strong> – the attr on the skeleton that we’re pulling the pose from, ‘bpose’ or ‘tpose’ by default</li>
<li><strong>skip_attrs</strong> – attrs we’re not interested in comparing, default [‘radius’, ‘visibility’]</li>
<li><strong>nodetypes</strong> – [] types of nodes we’re going to compare, default [‘joint’]</li>
<li><strong>longname</strong> – if True (default, we validate the dag path complete, else we use short name matching only</li>
<li><strong>suppress</strong> – suppress the results popup and just handle the return</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Red9.pro_pack.core.rigutils.skeleton_pose_compare_attr_to_file">
<code class="descname">skeleton_pose_compare_attr_to_file</code><span class="sig-paren">(</span><em>skel, filepath=None, attr='bpose', skip_attrs=['radius', 'visibility'], nodetypes='joint', longname=True, suppress=True</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.rigutils.skeleton_pose_compare_attr_to_file" title="Permalink to this definition">¶</a></dt>
<dd><p>compare one of the internal pose attrs against a given pose file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>skel</strong> – root skeleton to pull the pose attr from</li>
<li><strong>filepath</strong> – the filepath to the master pose file we’re comparing against, if left blank we prompt for a filepath</li>
<li><strong>attr</strong> – internal pose attr we’re comparing, bpose or tpose</li>
<li><strong>skip_attrs</strong> – attrs we’re not interested in comparing, default [‘radius’, ‘visibility’]</li>
<li><strong>nodetypes</strong> – [] types of nodes we’re going to compare, default [‘joint’]</li>
<li><strong>longname</strong> – if True (default, we validate the dag path complete, else we use short name matching only</li>
<li><strong>suppress</strong> – suppress the results popup and just handle the return</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Red9.pro_pack.core.rigutils.skeleton_from_skinned_mesh">
<code class="descname">skeleton_from_skinned_mesh</code><span class="sig-paren">(</span><em>mesh</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.rigutils.skeleton_from_skinned_mesh" title="Permalink to this definition">¶</a></dt>
<dd><p>from a list of skinned meshes return the root skeleton. This assumes that these are all skinned to the same base root skeleton</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>mesh</strong> – list of nodes we’re wanting to inspect</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Red9.pro_pack.core.rigutils.joint_duplicate_fresh">
<code class="descname">joint_duplicate_fresh</code><span class="sig-paren">(</span><em>joint</em>, <em>newname</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.rigutils.joint_duplicate_fresh" title="Permalink to this definition">¶</a></dt>
<dd><p>duplicate the joint from fresh so there’s no legacy to any current
custom attrs or data</p>
</dd></dl>

<dl class="function">
<dt id="Red9.pro_pack.core.rigutils.hik_characternode_from_joint">
<code class="descname">hik_characternode_from_joint</code><span class="sig-paren">(</span><em>joint</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.rigutils.hik_characternode_from_joint" title="Permalink to this definition">¶</a></dt>
<dd><p>from a given joint we look for a connected HIKCharacterNode, we scan from the given joint,
up to that skeletons rootJnt then scan back down in case the given joint isn’t part of the definitions</p>
<p>:return MetaHIKCharacterNode class directly</p>
</dd></dl>

<dl class="function">
<dt id="Red9.pro_pack.core.rigutils.hik_characterize_save_data">
<code class="descname">hik_characterize_save_data</code><span class="sig-paren">(</span><em>rootjnt</em>, <em>attr='hik_plugs'</em>, <em>suppress=False</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.rigutils.hik_characterize_save_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Triggered in the RigManager when you save the tpose, this is an additional attr
that holds the hik definition connection data</p>
</dd></dl>

<dl class="function">
<dt id="Red9.pro_pack.core.rigutils.hik_characterize_from_tpose">
<code class="descname">hik_characterize_from_tpose</code><span class="sig-paren">(</span><em>rootjnt=None</em>, <em>filepath=None</em>, <em>name=None</em>, <em>load_tpose=True</em>, <em>matchMethod='base'</em>, <em>hikdict=None</em>, <em>openui=True</em>, <em>force_lock=False</em>, <em>remove_current=True</em>, <em>disable_evaluation=False</em>, <em>skip_attrs=[]</em>, <em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.rigutils.hik_characterize_from_tpose" title="Permalink to this definition">¶</a></dt>
<dd><p>from a stored out tpose rebuild the HIK characterization. This creates the HIK node (name),
reconnects all of the plugs then loads the tpose up before locking the HIKCharacterization.
If the pose of HIK is invalid you’ll get a warning at the end of the procedure.
By default if you don’t pass in filepath we use the ‘tpose’ and ‘hik_plugs’ attrs
created by the RigManager to build this data from</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">this will unlock all transforms on the skeleton as we need to have them unlocked for the HIK Characterzation to lock correctly</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>roojnt</strong> – if given this is the root of the skeleton we’re going to load the definition into, else we use the longnames of the nodes stored in the pose data</li>
<li><strong>filepath</strong> – path to the tpose, stored in r9Pose format from the RigManager</li>
<li><strong>name</strong> – hik node name to create. If one was found in the scene to begin with we use that if name isn’t given</li>
<li><strong>load_tpose</strong> – if True we not only load the HIK connections but also load the actual TPose from the tpose file directly, else we just load the hik_plug data</li>
<li><strong>matchMethod</strong> – like all r9pose functions this is the method we use to match the joint lists together</li>
<li><strong>hikdict</strong> – if given this is a correctly formatted dict with the hikdata already build, used for passing data between skeletons when needed</li>
<li><strong>openui</strong> – open up the HIK window a the end of the proc so you can check the characterization manually</li>
<li><strong>force_lock</strong> – if True we ignore the checkcharacterization() results and lock regardless. This may cause issues if the skeleton isn’t in correct alignment</li>
<li><strong>remove_current</strong> – if True and name is set then we force delete any current connected HIKNode before making the new one</li>
<li><strong>disable_evaluation</strong> – if True we disable the evaluation of deformers when we load up the data so that the skeleton can reach the required T-Pose from the stored data.</li>
<li><strong>skip_attrs</strong> – [] added so you could by-pass the loading of specific attrs if needed, ie [‘translateX’,’translateY’,translateZ’] to skip the loading of the</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">1 if created and valid, 0 if created but invalid or failed to create, -1 if created and found as invalid characterization</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Red9.pro_pack.core.rigutils.hik_get_non_connected_leaf_jnts">
<code class="descname">hik_get_non_connected_leaf_jnts</code><span class="sig-paren">(</span><em>rootjnt</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.rigutils.hik_get_non_connected_leaf_jnts" title="Permalink to this definition">¶</a></dt>
<dd><p>from a given skeleton root, return all child joints that aren’t connect to 
a HIKCharacterNode.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>rootjnt</strong> – the skeleton root we’re going to process</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Red9.pro_pack.core.rigutils.hik_rename_skeleton_from_pose">
<code class="descname">hik_rename_skeleton_from_pose</code><span class="sig-paren">(</span><em>rootjnt</em>, <em>posefile</em>, <em>replace=[]</em>, <em>rename=True</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.rigutils.hik_rename_skeleton_from_pose" title="Permalink to this definition">¶</a></dt>
<dd><p>rename a given skeleton based on the hik_plug dict in a given pose file. For this we
cross reference the skeletons current hik mapping and then rename connected joints by 
pulling the mapping names from the pose file hik_data block.</p>
<p>This is used primarily internally to quickly rename skeletons and verify names from a
given master pose file, using the hik_plugs as the mapping</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>rootjnt</strong> – the skeleton root of the skeleton we’re going to rename</li>
<li><strong>posefile</strong> – the pose file we’re going to use to extract the naming from</li>
<li><strong>replace</strong> – [str, str] a simple replacement call in the renamer to allow you to
do srt.replace function in the rename, replace=[‘_drv’, ‘’] will strip the ‘_drv’
suffix from the renamed metahuman skeleton</li>
<li><strong>rename</strong> – if not True we only generate the return name mapping and don’t actually run the rename call itself</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:return [(oldname, newname),..]  returns a list or pairs so this data can be used elsewhere (shortnames)</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">we use the shortname of the joint as the key in the .pose file mapping dict so the source skeleton 
data can’t have duplicate named joints in it. The destination skeleton is dealt with slightly 
differently so duplicate joint names aren’t an issue there.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="Red9.pro_pack.core.rigutils.add_sparator_attr">
<code class="descname">add_sparator_attr</code><span class="sig-paren">(</span><em>node</em>, <em>info=''</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.rigutils.add_sparator_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>Maya has no way of adding a separator attr to the channelBox so this manages the next best thing.
This uses a managed “_breaker_0x” attr but we use a consistent “niceName” so the breakers shows as 
the same length for all consistently regardless if you add 5 of them to the same node</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>node</strong> – the node we’re adding a new separator too</li>
<li><strong>info</strong> – if given this is shown as the enum text, else we use “__________”</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">if the last attr on the node is a previous separator then one won’tbe added. Also if “info” 
is passed in and a separator exists with that info then again, the code will return without creating a new one</p>
</div>
</dd></dl>

<dl class="function">
<dt id="Red9.pro_pack.core.rigutils.export_r9pose_to_fbx_mobu">
<code class="descname">export_r9pose_to_fbx_mobu</code><span class="sig-paren">(</span><em>poses=[]</em>, <em>pose_folder=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.rigutils.export_r9pose_to_fbx_mobu" title="Permalink to this definition">¶</a></dt>
<dd><p>from a given list of r9Pose files load them onto the current mrig and export
them as a single frame FBX skeleton files for MoBu usage. This requires a correctly
setup mRig and mExportTag system in a clean scene</p>
<p>process as follows:
* expects a single mRig in the scene with an ExportTag setup
* we cutKeys on mRig
* load the single frame pose
* create a 1 frame ExportLoop
* send that export loop to the main exporter to generate the skeletal fbx file, respecting all current FBX settings</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>poses</strong> – if given this is the list of posefiles (full paths) to process</li>
<li><strong>pose_folder</strong> – if given this builds the poses list up from all found .pose files in the given directory</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Red9.pro_pack.core.rigutils.add_unreal_ik_hand_feet_jnts">
<code class="descname">add_unreal_ik_hand_feet_jnts</code><span class="sig-paren">(</span><em>rootjnt</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.rigutils.add_unreal_ik_hand_feet_jnts" title="Permalink to this definition">¶</a></dt>
<dd><p>simple proc to insert the standard ik_foot / ik_hand root jnts to a given skeleton.
This uses the HIK plugs to id the wrists and feet, creates the joints, then binds them 
as per the standard Unreal Mannequin setup. We ID the hand and foot joints by either
checking the hik plugs (recommended) or we use simply use the standard Mannequin joint names</p>
<p>this builds and validates:</p>
<dl class="docutils">
<dt>ik_hand_root&gt;</dt>
<dd><dl class="first last docutils">
<dt>&gt; ik_hand_gun</dt>
<dd>&gt; ik_hand_l
&gt; ik_hand_r</dd>
</dl>
</dd>
<dt>ik_foot_root</dt>
<dd>&gt; ik_foot_l
&gt; ik_foot_r</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>rootjnt</strong> – the root joint of the skeleton we’re going to add / setup the joints under</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Red9.pro_pack.core.rigutils.reset_hierarchy_overrides">
<code class="descname">reset_hierarchy_overrides</code><span class="sig-paren">(</span><em>nodes</em>, <em>hierarchy=True</em>, <em>inc_shapes=True</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.rigutils.reset_hierarchy_overrides" title="Permalink to this definition">¶</a></dt>
<dd><p>this is designed to reset the main display flags on a hierarchy, usually
reversing what a rigger may have done to hide them from a user in the first place.
This will only fail to set the attrs only if they’ve got incoming connections and
will do the following, regardless of these attrs being locked.</p>
<ul class="simple">
<li>turning on visibility</li>
<li>turning on lodVisibility</li>
<li>disabling overrideDisplayType</li>
<li>reset overrideEnabled to “Normal” = 0</li>
<li>reset overrideLevelOfDetail to “Full” = 0</li>
<li>reset overrideVisibility = 1</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nodes</strong> – nodes we’re going to process</li>
<li><strong>hierarchy</strong> – if True we run listRelatives on the given nodes and extend the process list</li>
<li><strong>in_shapes</strong> – do we process shape related nodes or not, default is True</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Red9.pro_pack.core.rigutils.extract_pole_vector">
<code class="descname">extract_pole_vector</code><span class="sig-paren">(</span><em>startjnt</em>, <em>polejnt</em>, <em>endjnt</em>, <em>prefix</em>, <em>create=True</em>, <em>ctrl=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.rigutils.extract_pole_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>create a node thats on the plane for perfect poleVector position
with no movement.
This is in testing</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>startjnt</strong> – the start of the jnt chain we’re calculating against</li>
<li><strong>polejnt</strong> – the polejnt in the jnt chain we’re calculating against</li>
<li><strong>endjnt</strong> – the end of the jnt chain we’re calculating against</li>
<li><strong>prefix</strong> – only used if create is True, this is the naming prefix for all node generated</li>
<li><strong>create</strong> – if True we create a node group with the relative trnasform for the pole Vector</li>
<li><strong>ctrl</strong> – if not create this is the node that will get the resulting world transform data applied</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the xform data of the resulting transform (finalV, finalV.x, finalV.y, finalV.z)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Red9.pro_pack.core.rigutils.sin_driver_expression">
<code class="descname">sin_driver_expression</code><span class="sig-paren">(</span><em>driver_attr</em>, <em>driven_attrs</em>, <em>sin_length</em>, <em>start_driver_value=0.0</em>, <em>end_driver_value=1.0</em>, <em>output_value=10.0</em>, <em>dynamic=True</em>, <em>name='sin_driver_expression'</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.core.rigutils.sin_driver_expression" title="Permalink to this definition">¶</a></dt>
<dd><p>simple expression setup to drive things like bendshapes on/off via a sine ease-in/out
this has a single input attr, then drives x number of attrs through 0-output_value-0 staggered
such that the last transition ends at the end_value</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>driver_attr</strong> – the attribute thats going to drive the expression input</li>
<li><strong>driven_attrs</strong> – the attributes we’re going to drive</li>
<li><strong>sin_length</strong> – the duration of each transition complete from 0-1-0</li>
<li><strong>end_driver_value</strong> – the value of the driver_attr that will complete the transitions</li>
<li><strong>output_value</strong> – the value we’ll drive each attribute too</li>
<li><strong>dynamic</strong> – if True then the expression is left such that the inputs could be modified easily,
else the values are written into the expression itself</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return peaks:</th><td class="field-body"><p class="first last">the  values of the driver_attr where the driven_attrs are at their peak</p>
</td>
</tr>
</tbody>
</table>
<p>the driver for the effect is the line here, if we treat the driver_attr as units of time then:</p>
<p>float $weight1 = sin((clamp(A, B, $driven_attr) - A) * 3.14159 / C);</p>
<p>where we clamp in input of the sin to the start and end time for this object such that:
A is the start time for this nodes transition
B is the end time for this nodes transition
C is the duration of the transition, ie the time it takes for the sin to go through 0-1-0
$driven_attr is the attribute (value) we’re driving</p>
</dd></dl>

</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Red9_Pro_r9file.html" class="btn btn-neutral float-left" title="Pro_Pack : r9file" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="Red9_Pro_shaders.html" class="btn btn-neutral float-right" title="Pro_Pack : shaders" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Red9 Consultancy Limited.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>