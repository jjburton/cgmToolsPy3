<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pro_Pack : tools : deformer_tools &mdash; Red9 3.0 documentation</title><link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Pro_Pack : tools : health_manager" href="Red9_Pro_health_manager.html" />
    <link rel="prev" title="Pro_Pack : tools : anim_trails" href="Red9_Pro_anim_trails.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> Red9<img src="../../_static/Red9_ProPack_logo.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                3.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../red9core_templates/Red9_AnimationUtils.html">Red9_AnimationUtils</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../red9core_templates/Red9_Audio.html">Red9_Audio</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../red9core_templates/Red9_Core.html">Red9_CoreUtils</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../red9core_templates/Red9_General.html">Red9_General</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../red9core_templates/Red9_Meta.html">Red9_Meta</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../red9core_templates/Red9_PoseSaver.html">Red9_PoseSaver</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../red9core_templates/Red9_Setup.html">Red9_Setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../red9core_templates/Red9_Tools.html">Red9_Tools</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Red9_Pro_anim_map.html">Pro_Pack : anim_map</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Red9_Pro_animation.html">Pro_Pack : animation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Red9_Pro_audio.html">Pro_Pack : audio</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Red9_Pro_capture.html">Pro_Pack : capture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Red9_Pro_deformers.html">Pro_Pack : deformers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Red9_Pro_export.html">Pro_Pack : exporter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Red9_Pro_general.html">Pro_Pack : general</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Red9_Pro_importexport.html">Pro_Pack : importexport</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Red9_Pro_metadata_pro.html">Pro_Pack : metadata_pro</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Red9_Pro_optimiser.html">Pro_Pack : optimiser</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Red9_Pro_perforce.html">Pro_Pack : perforce</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Red9_Pro_project.html">Pro_Pack : project</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Red9_Pro_r9data.html">Pro_Pack : r9Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Red9_Pro_r9file.html">Pro_Pack : r9file</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Red9_Pro_rigutils.html">Pro_Pack : rigutils</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Red9_Pro_shaders.html">Pro_Pack : shaders</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Red9_Pro_skinning.html">Pro_Pack : skinning</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Red9_Pro_uibase.html">Pro_Pack : uibase</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Red9_Pro_anim_binder.html">Pro_Pack : tools : anim_binder</a></li>
<li class="toctree-l1"><a class="reference internal" href="Red9_Pro_anim_tools.html">Pro_Pack : tools : anim_tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="Red9_Pro_anim_trails.html">Pro_Pack : tools : anim_trails</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Pro_Pack : tools : deformer_tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="Red9_Pro_health_manager.html">Pro_Pack : tools : health_manager</a></li>
<li class="toctree-l1"><a class="reference internal" href="Red9_Pro_metahuman_tools.html">Pro_Pack : tools : metahuman_tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="Red9_Pro_project_manager.html">Pro_Pack : tools : project_manager</a></li>
<li class="toctree-l1"><a class="reference internal" href="Red9_Pro_rig_manager.html">Pro_Pack : tools : rig_manager</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../puppet/Red9_Pro_finger_pose_creator.html">Pro_Pack : puppet : finger_pose_creator</a></li>
<li class="toctree-l1"><a class="reference internal" href="../puppet/Red9_Pro_ikfk_match.html">Pro_Pack : puppet : ikfk_match</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Red9</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Pro_Pack : tools : deformer_tools</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/red9pro_templates/tools/Red9_Pro_deformer_tools.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="pro-pack-tools-deformer-tools">
<h1>Pro_Pack : tools : deformer_tools<a class="headerlink" href="#pro-pack-tools-deformer-tools" title="Permalink to this headline">¶</a></h1>
<p>ProPack rig_manager module is the main UI wrapping for all of the RigManager setups.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># import statement for the module via the r9pro decompiler</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Red9.pro_pack</span> <span class="k">import</span> <span class="n">r9pro</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r9deformer_tools</span> <span class="o">=</span> <span class="n">r9pro</span><span class="o">.</span><span class="n">r9import</span><span class="p">(</span><span class="s1">&#39;r9deformer_tools&#39;</span><span class="p">)</span>
</pre></div>
</div>
<span class="target" id="module-Red9.pro_pack.tools.deformer_tools"></span><p>transfer the skin / deformation from the source mesh to target, transferring the deformation.
This was originally written to transfer the deformation of eyelids into the facial meniscus mesh (wetness around the eyeball)
We were running the deformation using a proxyWrap from the main facial mesh but that was slow and not going into the GPU.
This was the solution, xfer the deformation stack directly into the meniscus so evaluation was properly threaded / parallel</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="function">
<dt id="Red9.pro_pack.tools.deformer_tools.get_ids">
<code class="descname">get_ids</code><span class="sig-paren">(</span><em>sparse_array</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.tools.deformer_tools.get_ids" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Red9.pro_pack.tools.deformer_tools.get_skin_fn">
<code class="descname">get_skin_fn</code><span class="sig-paren">(</span><em>skin</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.tools.deformer_tools.get_skin_fn" title="Permalink to this definition">¶</a></dt>
<dd><p>simple OpenMayaAnim.MFnSkinCluster return</p>
</dd></dl>

<dl class="function">
<dt id="Red9.pro_pack.tools.deformer_tools.get_dag_path">
<code class="descname">get_dag_path</code><span class="sig-paren">(</span><em>mesh=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.tools.deformer_tools.get_dag_path" title="Permalink to this definition">¶</a></dt>
<dd><p>simple OpenMaya.MDagPath return</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">this takes either the transform or the shape node but will
ALWAYS return the mDagPath for the shape node not the transform</p>
</div>
</dd></dl>

<dl class="function">
<dt id="Red9.pro_pack.tools.deformer_tools.build_uv_kdtree">
<code class="descname">build_uv_kdtree</code><span class="sig-paren">(</span><em>mesh_name</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.tools.deformer_tools.build_uv_kdtree" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Red9.pro_pack.tools.deformer_tools.get_vertex_uv">
<code class="descname">get_vertex_uv</code><span class="sig-paren">(</span><em>mesh_name</em>, <em>vertex_index</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.tools.deformer_tools.get_vertex_uv" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Red9.pro_pack.tools.deformer_tools.find_closest_vertex_in_uv_space">
<code class="descname">find_closest_vertex_in_uv_space</code><span class="sig-paren">(</span><em>source_mesh</em>, <em>source_vertex_index</em>, <em>target_mesh</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.tools.deformer_tools.find_closest_vertex_in_uv_space" title="Permalink to this definition">¶</a></dt>
<dd><p>find the nearest matching vert to the source vtx but based on the uv space</p>
<p>Issue here is that we’re finding closest vertex NOT closest point on surface as the
getClostestPoint call does. Need to figure this one out</p>
</dd></dl>

<dl class="function">
<dt id="Red9.pro_pack.tools.deformer_tools.copy_deformers">
<code class="descname">copy_deformers</code><span class="sig-paren">(</span><em>deformers=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.tools.deformer_tools.copy_deformers" title="Permalink to this definition">¶</a></dt>
<dd><p>copy the deformer stack from the first selected mesh to the subsequent selections</p>
</dd></dl>

<dl class="function">
<dt id="Red9.pro_pack.tools.deformer_tools.replace_completely">
<code class="descname">replace_completely</code><span class="sig-paren">(</span><em>original, target, deformer_types=['blendShape', 'skinCluster', 'softMod']</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.tools.deformer_tools.replace_completely" title="Permalink to this definition">¶</a></dt>
<dd><p>&lt;&lt;&lt; HARD CORE: BE VERY CAREFUL HERE! &gt;&gt;&gt;</p>
<p>Replace the orginialShape with that of the given target shape and, optionally, xfer deformers 
from the target geo to the original geo in one go.</p>
<p>‘original’ is the mesh who’s topology, uvs, shaders &amp; deformation we want to replace with that of the ‘target’. 
Think of this as a way of completely updating a rigs setup to a new model from the modelling team.
We replace the originalGeo in the destination stack, hence updating the original mesh so it 
becomes the target geo.</p>
<p>If deformer_types are set (defaults to [‘blendShape’, ‘skinCluster’]) then we also replace/sync the 
blendshape &amp; skinCluster data from the target back to the original so that everything is in sync. 
This basically completely updates a mesh and all of it’s deformation with that of the target.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>original</strong> – the mesh who’s topology &amp; deformation stack we’re looking to update</li>
<li><strong>target</strong> – the input mesh we’re going to update the original shape with</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>this transfers everything for from the target to the original mesh including:</p>
<ul class="last simple">
<li>vertex positions</li>
<li>edge and face data</li>
<li>UVsets (we sync both uvset channels and the vtx data)</li>
<li>normals</li>
<li>shaders</li>
</ul>
</div>
</dd></dl>

<dl class="function">
<dt id="Red9.pro_pack.tools.deformer_tools.create_duplicate_faces">
<code class="descname">create_duplicate_faces</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.tools.deformer_tools.create_duplicate_faces" title="Permalink to this definition">¶</a></dt>
<dd><p>duplicate the selected faces into a new mesh object, ready to use as a temp
mesh in the getClosestPoint calls</p>
</dd></dl>

<dl class="function">
<dt id="Red9.pro_pack.tools.deformer_tools.calculate_barycentric_coords">
<code class="descname">calculate_barycentric_coords</code><span class="sig-paren">(</span><em>source_mesh</em>, <em>target_mesh</em>, <em>source_faces=[]</em>, <em>target_verts=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.tools.deformer_tools.calculate_barycentric_coords" title="Permalink to this definition">¶</a></dt>
<dd><p>from a given source_mesh and target mesh, calculate a mapping table
using barycentricCoords. return a mapping dic</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>source_mesh</strong> – the mesh we’re using to find closest point / coordinates on</li>
<li><strong>arget_mesh</strong> – the mesh we’re comparing to the source</li>
<li><strong>source_faces</strong> – [shp.f[int], shp.f[int],…] array of faces which will be used in the closest point calculations. 
If this is blank (default) then the getClosestPoint is calculated against the entire source mesh.
This allows us to limit the area of mesh that we’re going to consider</li>
<li><strong>target_verts</strong> – [shp.vtx[int], shp.vtx[int],…] array of vtxs that will limit the data being returned in the mapping,
else we return all verts with their mapping info</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li>mapping[vertId][‘b_coords’] = (b_coords[0], b_coords[1], (1-b_coords[0]-b_coords[1]))      # barycentric coordinate mapping within the triangle below</li>
<li>mapping[vertId][‘vertices’] = [vertID, vertID, vertId]                                     # triangle_vertices that the target vtx fall within on the source mesh</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">the source_faces args changes the way the code matches the target_vertex data. It becomes a rigid match, vert to closest vert
rather than returning the data on the mesh surface as we do is this isn’t passed in, ie, vertID matches vertID instead of 
MMeshIntersector.getClosestPoint(mPoint). This isn’t as desirable so should only be used if mesh density is consistent between source and target.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="Red9.pro_pack.tools.deformer_tools.transfer_blendshape_data">
<code class="descname">transfer_blendshape_data</code><span class="sig-paren">(</span><em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.tools.deformer_tools.transfer_blendshape_data" title="Permalink to this definition">¶</a></dt>
<dd><p>transfer the given blendshape data from the given source mesh to the target mesh</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>source_mesh</strong> – the input original mesh (shape), this does take transform node as input but we advise you pass in the shape</li>
<li><strong>target_mesh</strong> – the mesh we’re transferring the deformers too (shape), this does take transform node as input but we advise you pass in the shape</li>
<li><strong>deformer_node</strong> – the deformer we’re looking to transfer, by name</li>
<li><strong>foc</strong> – if True the deformer added will be added at the front of the chain</li>
<li><strong>barycentric</strong> – switch between vertex index based transfer and closest point in world space via barycentric coordinates</li>
<li><strong>layered_deformation</strong> – blendshape xfer, if False we add new targets to the current blendshape (if found),
else we create a new blendshape, in a layered deformation stack (default for VFX work)</li>
<li><strong>map_names</strong> – if True we name the new deformers the same as the source but append ‘_xfer’ to the end</li>
<li><strong>blends_with_deltas_only</strong> – if True we only add blend targets who’s deltas would alter the target mesh</li>
<li><strong>blend_delta_tolerance</strong> – the tolerance at which a delta is assumed to alter the mesh.
The higher this is the more a delta has to move the target mesh in-order for the blendshape to be added</li>
<li><strong>blend_map_inputs</strong> – if True we cast the inputs of the source blendshape targets into the targets of the destination
blend. This way if the source was connected to a facial rig, the destination blendshape would share those input connections</li>
<li><strong>blend_sync_mute_state</strong> – False by default: if True we sync the current “muted” state of the new target with it’s source target state in the ShapeEditor</li>
<li><strong>specific_blend_targets</strong> – [] if given this is a specific list of blendshape target names that we’re aiming to transfer,
if the blend target isn’t in the list then it gets skipped</li>
<li><strong>reset_non_selected</strong> – if target_verts are given this falg determines if NON selected verts who may have current blendshape data,
are maintained, or reset during the transfer, default is to maintain</li>
<li><strong>target_verts</strong> – [shp.vtx[int], shp.vtx[int],…] list of vertex’s on the target mesh, limiting the effect of the blendshape transfer to just these verts</li>
<li><strong>source_faces</strong> – [shp.f[int], shp.f[int],…] list of faces on the source mesh to consider within the barycentric coordinate transfer. This is a 
complex input to understand. Think of it as limiting the area of the source mesh thats used in the coordinate lookup &amp; that will ultimately drive the target mesh. 
Originally added so you could select an edge loop around the eye socket that would then limit eyelash transfer to just that loop. Useful as it means 
you can ignore the influence of things like the upper inner brow area which otherwise may give you bad results on eyelash shapes.</li>
<li><strong>blend_remove_empty_indexes</strong> – when processing the source we either retain empty indexes when creating the new target blendshape, or we remove them from the data,
case in point, source has had the first 5 blendtargets generated deleted, leaving 5 empty indexes. If this flag is True then the first index on the 
new blendshape will be 0 else it will be 6</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">if a blendShape target is in tangentSpace rather than objectSpace then the transfer will more than likely fail.
Need to look at resolving this in future builds or at least throwing a warning against it</p>
</div>
</dd></dl>

<dl class="function">
<dt id="Red9.pro_pack.tools.deformer_tools.transfer_skincluster_data">
<code class="descname">transfer_skincluster_data</code><span class="sig-paren">(</span><em>source_mesh</em>, <em>target_mesh</em>, <em>deformer_node</em>, <em>foc=True</em>, <em>barycentric=False</em>, <em>layered_deformation=False</em>, <em>map_names=False</em>, <em>target_verts=[]</em>, <em>source_faces=[]</em>, <em>barycentric_mapping={}</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.tools.deformer_tools.transfer_skincluster_data" title="Permalink to this definition">¶</a></dt>
<dd><p>transfer the given skinCluster data from the given source mesh to the target mesh</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>source_mesh</strong> – the input original mesh (shape), this does take transform node as input but we advise you pass in the shape</li>
<li><strong>target_mesh</strong> – the mesh we’re transferring the deformers too (shape), this does take transform node as input but we advise you pass in the shape</li>
<li><strong>deformer_node</strong> – the deformer we’re looking to transfer, by name</li>
<li><strong>foc</strong> – if True the deformer added will be added at the front of the chain</li>
<li><strong>barycentric</strong> – switch between vertex index based transfer and closest point in world space via barycentric coordinates</li>
<li><strong>layered_deformation</strong> – if False (default) we delete the current skinCluster (if found) and create and setup a new one, 
if True we create a new skinCluster regardless, creating a layered deformation stack (default for VFX work)</li>
<li><strong>map_names</strong> – if True we name the new deformers the same as the source but append ‘_xfer’ to the end</li>
<li><strong>target_verts</strong> – [shp.vtx[int], shp.vtx[int],…] list of vertex’s on the target mesh, limiting the effect of the blendshape transfer to just these verts</li>
<li><strong>source_faces</strong> – [shp.f[int], shp.f[int],…] list of faces on the source mesh to consider within the barycentric coordinate transfer. This is a 
complex input to understand. Think of it as limiting the area of the source mesh thats used in the coordinate lookup &amp; that will ultimately drive the target mesh. 
Originally added so you could select an edge loop around the eye socket that would then limit eyelash transfer to just that loop. Useful as it means 
you can ignore the influence of things like the upper inner brow area which otherwise may give you bad results on eyelash shapes.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Red9.pro_pack.tools.deformer_tools.transfer_softmod_data">
<code class="descname">transfer_softmod_data</code><span class="sig-paren">(</span><em>source_mesh</em>, <em>target_mesh</em>, <em>deformer_node</em>, <em>map_names=False</em>, <em>foc=True</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.tools.deformer_tools.transfer_softmod_data" title="Permalink to this definition">¶</a></dt>
<dd><p>transfer the given softMod data from the given source mesh to the target mesh</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>source_mesh</strong> – the input original mesh (shape), this does take transform node as input but we advise you pass in the shape</li>
<li><strong>target_mesh</strong> – the mesh we’re transferring the deformers too (shape), this does take transform node as input but we advise you pass in the shape</li>
<li><strong>deformer_node</strong> – the deformer we’re looking to transfer, by name</li>
<li><strong>map_names</strong> – if True we name the new deformers the same as the source but append ‘_xfer’ to the end</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>This creates a new softMod deformer, then connects the inputs of the source softMod to this new deformer. This way you can have a 
master softMod, maybe the Red9 setup thats integrated with controllers etc, and link all of that data to the new softMod. 
Both deformers would then get driven by the same control data.</p>
<p class="last">One thing to note however, is that if you then delete the new softMod deformer natively in Maya UI, because it’s linked to the original, 
Maya will delete BOTH. Please use the delete button in the Deformation_transfer UI to delete as we manage this more carefully!</p>
</div>
</dd></dl>

<dl class="function">
<dt id="Red9.pro_pack.tools.deformer_tools.transfer_deformation_stack">
<code class="descname">transfer_deformation_stack</code><span class="sig-paren">(</span><em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.tools.deformer_tools.transfer_deformation_stack" title="Permalink to this definition">¶</a></dt>
<dd><p>transfer deformation stack from one mesh to another, currently supports skinCluster and blendShape.
Uses either barycentric co-ordinate space or simple index based transfer.</p>
<p>initially developed for Knuckles TV series &amp; Sonic3 to transfer the deformation from the base mesh over to all of the component  parts and mesh densities</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">transfer_deformation_stack</span><span class="p">(</span><span class="s1">&#39;C_body_GEOShape&#39;</span><span class="p">,</span> <span class="s1">&#39;L_meniscus_GEOShape&#39;</span><span class="p">,</span>  <span class="p">[</span><span class="n">skinCluster_body_GEO</span><span class="s1">&#39;, &#39;</span><span class="n">sculptBlend</span><span class="s1">&#39;])</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>source_mesh</strong> – the input original mesh (shape), this does take transform node as input but we advise you pass in the shape</li>
<li><strong>target_mesh</strong> – the mesh we’re transferring the deformers too (shape), this does take transform node as input but we advise you pass in the shape</li>
<li><strong>deformation_stack</strong> – the deformers we’re looking to transfer, by name</li>
<li><strong>foc</strong> – if True each deformer added will be added at the front of the chain</li>
<li><strong>barycentric</strong> – switch between vertex index based transfer and closest point in world space via barycentric coordinates</li>
<li><strong>layered_deformation</strong> – for blendshape xfer, if False we add new targets to the current blendshape (if found),
else we create a new blendshape in a layered deformation stack (default for VFX work). For skinCluster we either 
delete any current skinCluster and simply create a new one, or we layer stack a new skinCluster.</li>
<li><strong>map_names</strong> – if True we name the new deformers the same as the source but append ‘_xfer’ to the end</li>
<li><strong>blends_with_deltas_only</strong> – if True we only add blend targets who’s deltas would alter the target mesh</li>
<li><strong>blend_delta_tolerance</strong> – the tolerance at which a delta is assumed to alter the mesh.
The higher this is the more a delta has to move the target mesh in-order for the blendshape to be added</li>
<li><strong>blend_map_inputs</strong> – if True we cast the inputs of the source blendshape targets into the targets of the destination
blend. This way if the source was connected to a facial rig, the destination blendshape would share those input connections</li>
<li><strong>blend_sync_mute_state</strong> – False by default: if True we sync the current “muted” state of the new target with it’s source target state in the ShapeEditor</li>
<li><strong>specific_blend_targets</strong> – [] if given this is a specific list of blendshape target names that we’re aiming to transfer,
if the blend target isn’t in the list then it gets skipped</li>
<li><strong>target_verts</strong> – [shp.vtx[int], shp.vtx[int],…] list of vertex’s on the target mesh, limiting the effect of the blendshape transfer to just these verts</li>
<li><strong>source_faces</strong> – [shp.f[int], shp.f[int],…] list of faces on the source mesh to consider within the barycentric coordinate transfer. This is a 
complex input to understand. Think of it as limiting the area of the source mesh thats used in the coordinate lookup &amp; that will ultimately drive the target mesh. 
Originally added so you could select an edge loop around the eye socket that would then limit eyelash transfer to just that loop. Useful as it means 
you can ignore the influence of things like the upper inner brow area which otherwise may give you bad results on eyelash shapes.</li>
<li><strong>reset_non_selected</strong> – if target_verts are given, or selected, this flag determines if NON selected verts who may have current blendshape data,
are maintained, or reset during the transfer, default is to maintain</li>
<li><strong>blend_remove_empty_indexes</strong> – when processing the source we either retain empty indexes when creating the new target blendshape, or we remove them from the data,
case in point, source has had the first 5 blendtargets generated deleted, leaving 5 empty indexes. If this flag is True then the first index on the 
new blendshape will be 0 else it will be 6</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Red9.pro_pack.tools.deformer_tools.transfer_deformations_batch">
<code class="descname">transfer_deformations_batch</code><span class="sig-paren">(</span><em>source_meshes</em>, <em>target_meshes</em>, <em>matchMethod='index'</em>, <em>foc=True</em>, <em>barycentric=False</em>, <em>layered_deformation=True</em>, <em>map_names=False</em>, <em>blends_with_deltas_only=True</em>, <em>blend_delta_tolerance=0.01</em>, <em>blend_map_inputs=True</em>, <em>blend_sync_mute_state=False</em>, <em>blend_remove_empty_indexes=False</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.tools.deformer_tools.transfer_deformations_batch" title="Permalink to this definition">¶</a></dt>
<dd><p>batch wrap so you can transfer multiple mesh deformations at a go. 
If source_meshes or target_meshes are a group and not a mesh then we filter for all 
child meshes under these and process everything found, else we use these input lists as is</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>source_meshes</strong> – [] list of source meshes who’s deformations we want to transfer, OR top level grp for multiple child meshes</li>
<li><strong>target_meshes</strong> – [] list of target meshes that will get the new deformations, OR top level grp for multiple child meshes</li>
<li><strong>foc</strong> – if True each deformer added will be added at the front of the chain</li>
<li><strong>barycentric</strong> – switch between vertex index based transfer and closest point in world space via barycentric coordinates</li>
<li><strong>layered_deformation</strong> – for blendshape xfer, if False we add new targets to the current blendshape (if found),
else we create a new blendshape in a layered deformation stack (default for VFX work). For skinCluster we either 
delete any current skinCluster and simply create a new one, or we layer stack a new skinCluster.</li>
<li><strong>map_names</strong> – if True we name the new deformers the same as the source but append ‘_xfer’ to the end</li>
<li><strong>blends_with_deltas_only</strong> – if True we only add blend targets who’s deltas would alter the target mesh</li>
<li><strong>blend_delta_tolerance</strong> – the tolerance at which a delta is assumed to alter the mesh.
The higher this is the more a delta has to move the target mesh in-order for the blendshape to be added</li>
<li><strong>blend_map_inputs</strong> – if True we cast the inputs of the source blendshape targets into the targets of the destination
blend. This way if the source was connected to a facial rig, the destination blendshape would share those input connections</li>
<li><strong>blend_sync_mute_state</strong> – False by default: if True we sync the current “muted” state of the new target with it’s source target state in the ShapeEditor</li>
<li><strong>blend_remove_empty_indexes</strong> – when processing the source we either retain empty indexes when creating the new target blendshape, or we remove them from the data,
case in point, source has had the first 5 blendtargets generated deleted, leaving 5 empty indexes. If this flag is True then the first index on the 
new blendshape will be 0 else it will be 6</li>
<li><strong>matchMethod</strong> – <p>default ‘index’</p>
<ul>
<li>matchMethod=”index” : no intelligent matching, just purely zip the lists             together in the order they were given</li>
<li>matchMethod=”indexReversed” : no intelligent matching, just purely zip             the lists together in the reverse order they were given</li>
<li>matchMethod=”base” :  match each element by exact name (shortName) such             that Spine==Spine or REF1:Spine==REF2:Spine</li>
<li>matchMethod=”stripPrefix” : match each element by a relaxed naming convention             allowing for prefixes one side such that RigX_Spine == Spine</li>
<li>matchMethod=”stripSuffix” : match each element by a relaxed naming convention             allowing for suffixes one side such that Spine_DRV == Spine</li>
<li><dl class="first docutils">
<dt>matchMethod=”commonPrefix” <span class="classifier-delimiter">:</span> <span class="classifier">match each element by a relaxed naming convention             allowing for prefixes such that RigX_Spine == Spine. This tries to ID a single prefix on either</span></dt>
<dd>side and uses those as the keys for the match. “stripPrefix” method falls over if you have multiple
nodes where nodeA.endswith(nodeB) ie:/ spine_04 == drv_spine_04 but also spine_04 == drv_leg_spine_04</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>matchMethod=”commonSuffix” <span class="classifier-delimiter">:</span> <span class="classifier">match each element by a relaxed naming convention             allowing for suffixes such that Spine_DRV == Spine. This tries to ID a single suffix on either</span></dt>
<dd>side and uses those as the keys for the match. “stripSuffix” method falls over if you have multiple
nodes where nodeA.endswith(nodeB) ie:/ spine_04 == spine_04_drv but also spine_04 == spine_04_leg_drv</dd>
</dl>
</li>
<li>matchMethod=”mirrorIndex” : match via the nodes MirrorMarker</li>
<li>matchMethod=”metaData” : match the nodes based on their wiring connections to the MetaData framework</li>
</ul>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Red9.pro_pack.tools.deformer_tools.get_points">
<code class="descname">get_points</code><span class="sig-paren">(</span><em>path</em>, <em>space=2</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.tools.deformer_tools.get_points" title="Permalink to this definition">¶</a></dt>
<dd><p>get all the points of a given object as an MPointArray</p>
</dd></dl>

<dl class="function">
<dt id="Red9.pro_pack.tools.deformer_tools.set_points">
<code class="descname">set_points</code><span class="sig-paren">(</span><em>path</em>, <em>points</em>, <em>space=2</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.tools.deformer_tools.set_points" title="Permalink to this definition">¶</a></dt>
<dd><p>set the points of the object from the MPointArray</p>
</dd></dl>

<dl class="function">
<dt id="Red9.pro_pack.tools.deformer_tools.set_matrix_row">
<code class="descname">set_matrix_row</code><span class="sig-paren">(</span><em>matrix</em>, <em>newVector</em>, <em>row</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.tools.deformer_tools.set_matrix_row" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Red9.pro_pack.tools.deformer_tools.get_delta_shape">
<code class="descname">get_delta_shape</code><span class="sig-paren">(</span><em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.tools.deformer_tools.get_delta_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>create a delta mesh that is the result of extracting the sculptPose from the pose mesh.
This is designed to allow users to pass in a master facial sculpt mesh, then pose 
their current facial rig (MetaHuman for example) into a relative pose and then extract a 
delta thats the difference between the rig’s current pose (the pose mesh) and a target
master sculptPose. This delta can then be used as a blendshape delta.
This is expecting there to be an intermediate / original mesh attached to the pose
unless basemesh is passed in.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>pose</strong> – the deformed skin result</li>
<li><strong>sculptPose</strong> – the final result we’re trying to subtract the skinning from</li>
<li><strong>name</strong> – name of the resulting delta mesh</li>
<li><strong>basemesh</strong> – if our pose mesh hasn’t got an intermediateObject the process will bail
this allows us to by-pass that and pass in the basemesh directly</li>
<li><strong>build</strong> – True by default, build the delta into a mesh and return it. If False we return
an OpenMaya.MPointArray of the mesh point data for the delta without creating a mesh</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Red9.pro_pack.tools.deformer_tools.show_input_stack_ui">
<code class="descname">show_input_stack_ui</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.tools.deformer_tools.show_input_stack_ui" title="Permalink to this definition">¶</a></dt>
<dd><p>bodge to show the standard input lists</p>
</dd></dl>

<dl class="class">
<dt id="Red9.pro_pack.tools.deformer_tools.DeformerStack_UI">
<em class="property">class </em><code class="descname">DeformerStack_UI</code><span class="sig-paren">(</span><em>parent=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.tools.deformer_tools.DeformerStack_UI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">PySide2.QtWidgets.QMainWindow</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Ui_MainWindow</span></code></p>
<p>UI wrap for faster management of deformers</p>
<dl class="method">
<dt id="Red9.pro_pack.tools.deformer_tools.DeformerStack_UI.batch_set_meshes">
<code class="descname">batch_set_meshes</code><span class="sig-paren">(</span><em>mode</em>, <em>add=False</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.tools.deformer_tools.DeformerStack_UI.batch_set_meshes" title="Permalink to this definition">¶</a></dt>
<dd><p>set the source / target lists up based on the current selection.
If we try and add a single selected node thats NOT of type mesh, then we run 
the filterNode code to find all child ‘mesh’,’nurbsCurve’ or ‘nurbsSurface’ under that grp</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.tools.deformer_tools.DeformerStack_UI.batch_table_fill">
<code class="descname">batch_table_fill</code><span class="sig-paren">(</span><em>matchBy='stripPrefix'</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.tools.deformer_tools.DeformerStack_UI.batch_table_fill" title="Permalink to this definition">¶</a></dt>
<dd><p>fill the table in</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.tools.deformer_tools.DeformerStack_UI.batch_table_selected_items">
<code class="descname">batch_table_selected_items</code><span class="sig-paren">(</span><em>select_meshes=False</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.tools.deformer_tools.DeformerStack_UI.batch_table_selected_items" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.tools.deformer_tools.DeformerStack_UI.batch_table_move_item">
<code class="descname">batch_table_move_item</code><span class="sig-paren">(</span><em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.tools.deformer_tools.DeformerStack_UI.batch_table_move_item" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.tools.deformer_tools.DeformerStack_UI.batch_table_get_pairs">
<code class="descname">batch_table_get_pairs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.tools.deformer_tools.DeformerStack_UI.batch_table_get_pairs" title="Permalink to this definition">¶</a></dt>
<dd><p>return current list of pairs as a list of tuples</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.tools.deformer_tools.DeformerStack_UI.table_get_all_items">
<code class="descname">table_get_all_items</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.tools.deformer_tools.DeformerStack_UI.table_get_all_items" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.tools.deformer_tools.DeformerStack_UI.batch_remove_selected">
<code class="descname">batch_remove_selected</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.tools.deformer_tools.DeformerStack_UI.batch_remove_selected" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.tools.deformer_tools.DeformerStack_UI.batch_transfer">
<code class="descname">batch_transfer</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.tools.deformer_tools.DeformerStack_UI.batch_transfer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.tools.deformer_tools.DeformerStack_UI.verify_input_meshes">
<code class="descname">verify_input_meshes</code><span class="sig-paren">(</span><em>original_mesh</em>, <em>target_mesh</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.tools.deformer_tools.DeformerStack_UI.verify_input_meshes" title="Permalink to this definition">¶</a></dt>
<dd><p>verify the source and target meshes prior to running the xfer</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.tools.deformer_tools.DeformerStack_UI.select_source">
<code class="descname">select_source</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.tools.deformer_tools.DeformerStack_UI.select_source" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.tools.deformer_tools.DeformerStack_UI.blendshape_picker">
<code class="descname">blendshape_picker</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.tools.deformer_tools.DeformerStack_UI.blendshape_picker" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.tools.deformer_tools.DeformerStack_UI.blendshape_merge">
<code class="descname">blendshape_merge</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.tools.deformer_tools.DeformerStack_UI.blendshape_merge" title="Permalink to this definition">¶</a></dt>
<dd><p>merge 2 blendShapes in index space only!</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.tools.deformer_tools.DeformerStack_UI.select_deformer">
<code class="descname">select_deformer</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.tools.deformer_tools.DeformerStack_UI.select_deformer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.tools.deformer_tools.DeformerStack_UI.set_envelope">
<code class="descname">set_envelope</code><span class="sig-paren">(</span><em>mode</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.tools.deformer_tools.DeformerStack_UI.set_envelope" title="Permalink to this definition">¶</a></dt>
<dd><p>set the envelope of the selected deformers</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.tools.deformer_tools.DeformerStack_UI.delete_deformers">
<code class="descname">delete_deformers</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.tools.deformer_tools.DeformerStack_UI.delete_deformers" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.tools.deformer_tools.DeformerStack_UI.reorder">
<code class="descname">reorder</code><span class="sig-paren">(</span><em>direction</em>, <em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.tools.deformer_tools.DeformerStack_UI.reorder" title="Permalink to this definition">¶</a></dt>
<dd><p>note that this ONLY reorders around the deformers in the UI, it DOES NOT
reorder around other nodes in the history so be careful</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.tools.deformer_tools.DeformerStack_UI.debug_blend">
<code class="descname">debug_blend</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.tools.deformer_tools.DeformerStack_UI.debug_blend" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.tools.deformer_tools.DeformerStack_UI.selected_deformers">
<code class="descname">selected_deformers</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.tools.deformer_tools.DeformerStack_UI.selected_deformers" title="Permalink to this definition">¶</a></dt>
<dd><p>return the selected deformers from the UI list</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.tools.deformer_tools.DeformerStack_UI.xfer_stack">
<code class="descname">xfer_stack</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.tools.deformer_tools.DeformerStack_UI.xfer_stack" title="Permalink to this definition">¶</a></dt>
<dd><p>main transfer call</p>
</dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.tools.deformer_tools.DeformerStack_UI.closeEvent">
<code class="descname">closeEvent</code><span class="sig-paren">(</span><em>event</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.tools.deformer_tools.DeformerStack_UI.closeEvent" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="Red9.pro_pack.tools.deformer_tools.DeformerStack_UI.staticMetaObject">
<code class="descname">staticMetaObject</code><em class="property"> = &lt;PySide2.QtCore.QMetaObject object&gt;</em><a class="headerlink" href="#Red9.pro_pack.tools.deformer_tools.DeformerStack_UI.staticMetaObject" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="Red9.pro_pack.tools.deformer_tools.Blend_Targets_UI">
<em class="property">class </em><code class="descname">Blend_Targets_UI</code><span class="sig-paren">(</span><em>parent=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.tools.deformer_tools.Blend_Targets_UI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">PySide2.QtWidgets.QMainWindow</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Ui_MainWindow</span></code></p>
<p>UI wrap for faster management of deformers</p>
<dl class="method">
<dt id="Red9.pro_pack.tools.deformer_tools.Blend_Targets_UI.set_feedback">
<code class="descname">set_feedback</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.tools.deformer_tools.Blend_Targets_UI.set_feedback" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.tools.deformer_tools.Blend_Targets_UI.reset_selected">
<code class="descname">reset_selected</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.tools.deformer_tools.Blend_Targets_UI.reset_selected" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Red9.pro_pack.tools.deformer_tools.Blend_Targets_UI.pushdata">
<code class="descname">pushdata</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Red9.pro_pack.tools.deformer_tools.Blend_Targets_UI.pushdata" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="Red9.pro_pack.tools.deformer_tools.Blend_Targets_UI.staticMetaObject">
<code class="descname">staticMetaObject</code><em class="property"> = &lt;PySide2.QtCore.QMetaObject object&gt;</em><a class="headerlink" href="#Red9.pro_pack.tools.deformer_tools.Blend_Targets_UI.staticMetaObject" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Red9_Pro_anim_trails.html" class="btn btn-neutral float-left" title="Pro_Pack : tools : anim_trails" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="Red9_Pro_health_manager.html" class="btn btn-neutral float-right" title="Pro_Pack : tools : health_manager" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Red9 Consultancy Limited.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>